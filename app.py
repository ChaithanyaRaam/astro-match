# -*- coding: utf-8 -*-
"""AppAstro

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pyvKmVGMTElSlb3eaxD-9j7DISurV1Qa
"""

import streamlit as st
import swisseph as swe

from geopy.geocoders import MapBox
from datetime import datetime, time as dt_time

from timezonefinder import TimezoneFinder
import pytz
import random

import google.generativeai as genai
# ---------------------------------------------------------
# PAGE CONFIG
# ---------------------------------------------------------
st.set_page_config(
    page_title="Yugma",
    page_icon="üß°",
    layout="centered",
    initial_sidebar_state="expanded"
)
# ---------------------------------------------------------
# CONSTANTS / API KEYS
# ---------------------------------------------------------

MAPBOX_KEY = "pk.eyJ1IjoiY3JhYW0iLCJhIjoiY21qdmwycGtpMmJrdw3lc2RyeGh4NzI0ZCJ9.QDE8TkUAQFswm2XFBBxxaw"
# ---------------------------------------------------------
# SESSION STATE (GLOBAL ‚Äî DO NOT MOVE)
# ---------------------------------------------------------

# Navigation

# ---------------------------------------------------------
# SESSION STATE (GLOBAL)
# ---------------------------------------------------------
if "page" not in st.session_state:
    st.session_state.page = "Onboarding"

if "user" not in st.session_state:
    st.session_state.user = None

if "profiles" not in st.session_state:
    st.session_state.profiles = []

if "liked_profiles" not in st.session_state:
    st.session_state.liked_profiles = []

if "ai_bio" not in st.session_state:
    st.session_state.ai_bio = ""

if "shown_insights" not in st.session_state:
    st.session_state.shown_insights = set()

# ---------------------------------------------------------
# GLOBAL STYLES
# ---------------------------------------------------------
st.markdown("""
<style>
.stApp {
    background-color: #fffaf0;
}

/* Card container */
.card {
    background: #ffffff;
    border-radius: 14px;
    padding: 16px;
    margin-bottom: 18px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.06);
}

/* Badges (small insight pills) */
.badge {
    display: inline-block;
    background: #ffeaa7;
    color: #d35400;
    padding: 4px 8px;
    border-radius: 8px;
    font-size: 12px;
    margin-right: 6px;
}

/* AI score / couple summary */
.viral-card {
    border: 2px dashed #e17055;
    padding: 14px;
    border-radius: 12px;
    background: #ffffff;
    font-family: monospace;
}
</style>
""", unsafe_allow_html=True)
# ---------------------------------------------------------
# LOCATION UTILITIES (MAPBOX ‚Äî NO HARDCODED LAT/LON)
# ---------------------------------------------------------
@st.cache_data(show_spinner=False)
def get_coords(city_name: str):
    if not city_name:
        return None, None

    try:
        geolocator = MapBox(
            api_key=MAPBOX_KEY,
            user_agent="yugma_dating_app_v1"
        )
        location = geolocator.geocode(city_name, timeout=10)

        if location:
            return location.latitude, location.longitude

        return None, None

    except Exception:
        return None, None
# ---------------------------------------------------------
# VEDIC MATCH ENGINE (CORE + DATING LAYER)
# ---------------------------------------------------------
class VedicMatchEngine:
    def __init__(self):
        swe.set_ephe_path('')
        swe.set_sid_mode(swe.SIDM_LAHIRI, 0, 0)

        # --- Classical mappings ---
        self.nak_to_nadi = [
            0,1,2,2,1,0,0,1,2,
            0,1,2,2,1,0,0,1,2,
            0,1,2,2,1,0,0,1,2
        ]

        self.rashi_lords = [2,5,3,1,0,3,5,2,4,6,6,4]

        self.maitri_matrix = [
            [5,5,5,4,5,0,0],
            [5,5,4,1,4,0.5,0.5],
            [5,4,5,0.5,5,3,0.5],
            [4,1,0.5,5,0.5,5,4],
            [5,4,5,0.5,5,0.5,3],
            [0,0.5,3,5,0.5,5,5],
            [0,0.5,0.5,4,3,5,5]
        ]

    # -----------------------------------------------------
    # PLANETARY DATA (AUTHORITATIVE)
    # -----------------------------------------------------
    def get_planet_data(self, dt_obj, lat, lon):
        tf = TimezoneFinder()
        tz = tf.timezone_at(lat=lat, lng=lon) or "UTC"
        local_dt = pytz.timezone(tz).localize(dt_obj)
        utc_dt = local_dt.astimezone(pytz.utc)

        time_dec = (
            utc_dt.hour +
            utc_dt.minute / 60.0 +
            utc_dt.second / 3600.0
        )

        jd = swe.julday(
            utc_dt.year,
            utc_dt.month,
            utc_dt.day,
            time_dec
        )

        planets = {
            "Moon": swe.calc_ut(jd, swe.MOON, swe.FLG_SIDEREAL)[0][0],
            "Mars": swe.calc_ut(jd, swe.MARS, swe.FLG_SIDEREAL)[0][0],
            "Rahu": swe.calc_ut(jd, swe.MEAN_NODE, swe.FLG_SIDEREAL)[0][0]
        }

        cusps, _ = swe.houses(jd, lat, lon, b'P')
        asc_deg = cusps[0]

        def get_rashi(deg):
            return int(deg / 30)

        def get_house(deg, asc):
            return (int(deg / 30) - int(asc / 30) + 12) % 12 + 1

        return {
            "nakshatra": int(planets["Moon"] / 13.333333),
            "rashi": get_rashi(planets["Moon"]),
            "mars_deg": planets["Mars"],
            "mars_house": get_house(planets["Mars"], asc_deg),
            "rahu_house": get_house(planets["Rahu"], asc_deg)
        }

    # -----------------------------------------------------
    # CLASSICAL MATCH SCORE (36 GUNA STYLE ‚Äì SIMPLIFIED)
    # -----------------------------------------------------
    def calculate_match(self, b, g):
        score = 0

        # Nadi
        nadi_same = self.nak_to_nadi[b["nakshatra"]] == self.nak_to_nadi[g["nakshatra"]]
        nadi_score = 0 if nadi_same else 8
        score += nadi_score

        # Maitri
        maitri = (
            self.maitri_matrix[self.rashi_lords[b["rashi"]]][self.rashi_lords[g["rashi"]]] +
            self.maitri_matrix[self.rashi_lords[g["rashi"]]][self.rashi_lords[b["rashi"]]]
        ) / 2

        score += maitri * 4

        total = min(36, score + 10)

        # Manglik
        mang_houses = [1,2,4,7,8,12]
        b_mang = b["mars_house"] in mang_houses
        g_mang = g["mars_house"] in mang_houses
        flag = "Manglik Clash" if b_mang != g_mang else "Clean"

        return int(total), flag, nadi_score, maitri

    # -----------------------------------------------------
    # DATING INSIGHTS (PRODUCT LAYER)
    # -----------------------------------------------------
    def get_dating_insights(self, boy, girl):
        insights = {}

        # Emotional sync (Moon distance)
        nak_diff = abs(boy["nakshatra"] - girl["nakshatra"])
        if nak_diff <= 3:
            insights["emotional_sync"] = "Very emotionally aligned"
        elif nak_diff <= 6:
            insights["emotional_sync"] = "Emotionally compatible with adjustments"
        else:
            insights["emotional_sync"] = "Emotionally different but intriguing"

        # Chemistry (Mars proximity)
        mars_gap = abs(boy["mars_deg"] - girl["mars_deg"])
        if mars_gap < 20:
            insights["chemistry"] = "High intensity attraction"
        elif mars_gap < 40:
            insights["chemistry"] = "Balanced attraction"
        else:
            insights["chemistry"] = "Slow-burn connection"

        # Long-term signal
        score, flag, _, _ = self.calculate_match(boy, girl)
        if score >= 28:
            insights["long_term"] = "Strong long-term potential"
        elif score >= 22:
            insights["long_term"] = "Works with conscious communication"
        else:
            insights["long_term"] = "Fun but effort-heavy"

        insights["raw_flag"] = flag
        insights["score"] = score

        return insights
# ---------------------------------------------------------
# AI HELPERS ‚Äî GEN Z TRANSLATION LAYER
# ---------------------------------------------------------
def ai_couple_summary(api_key, name1, name2, insights):
    """
    AI ONLY rephrases engine insights.
    It does NOT invent or judge.
    """

    # Fallback (no AI key)
    if not api_key:
        return f"""
üî• Emotional vibe: {insights['emotional_sync']}
üí• Chemistry: {insights['chemistry']}
üß≠ Where this could go: {insights['long_term']}
"""

    try:
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel("gemini-1.5-flash")

        prompt = f"""
You are rewriting relationship insights for a Gen Z dating app.

STRICT RULES:
- Do NOT invent information
- Do NOT add astrology terms
- Only rephrase what is given
- Casual, modern, dating-app tone
- Max 4 short lines

COUPLE:
{name1} & {name2}

RAW INSIGHTS:
- Emotional sync: {insights['emotional_sync']}
- Chemistry: {insights['chemistry']}
- Long-term direction: {insights['long_term']}

OUTPUT FORMAT (exact):
üî• Emotional vibe:
üí• Chemistry:
üß≠ Where this could go:
"""

        response = model.generate_content(
            prompt,
            generation_config={"temperature": 0.7}
        )

        return response.text.strip()

    except Exception:
        return "‚ú® Interesting connection with potential worth exploring."
# =========================================================
# DUMMY PROFILES GENERATION
# =========================================================

def generate_dummy_profiles(user_gender):
    """
    Temporary profiles for MVP testing.
    Later this will be replaced by real users.
    """
    male_names = ["Aarav", "Kabir", "Rohan", "Ishaan"]
    female_names = ["Diya", "Mira", "Ananya", "Sana"]

    img_m = "https://images.unsplash.com/photo-1506794778202-cad84cf45f1d"
    img_f = "https://images.unsplash.com/photo-1544005313-94ddf0286df2"

    # If user is Male, generate female profiles. If user is Female, generate male profiles.
    names = female_names if user_gender == "Male" else male_names
    img = img_f if user_gender == "Male" else img_m

    profiles = []
    for i in range(8):
        profiles.append({
            "id": i,
            "name": random.choice(names),
            "age": random.randint(23, 32),
            "city": random.choice(["Chennai", "Bangalore", "Mumbai"]),
            "img": img,
            "dob": datetime(1995, random.randint(1, 12), random.randint(1, 28)),
            "tob": dt_time(random.randint(0, 23), 0)
        })
    return profiles

# =========================================================
# PAGE ROUTER (SINGLE SOURCE OF TRUTH)
# =========================================================

if st.session_state.user is None:
    # ---------------- ONBOARDING ----------------
    st.title("Welcome to Yugma üß°")
    st.caption("Dating, decoded through patterns ‚Äî not guesswork.")

    name = st.text_input("Your Name")
    dob = st.date_input("Date of Birth", datetime(1996, 1, 1))
    tob = st.time_input("Time of Birth", dt_time(12, 0))
    city = st.text_input("City of Birth")
    gender = st.radio("Your Gender", ["Male", "Female"]) # Added gender input

    api_key = st.text_input("Gemini API Key (optional)", type="password")

    # --- Integrated AI Bio Generation and Regenerate ---
    c1, c2 = st.columns([3, 1])

    # These variables are re-calculated within the button clicks, so no need for global scope here

    if c1.button("‚ú® Generate Bio with Yugma"):
        lat, lon = get_coords(city)

        if not lat:
            st.error("Please enter a valid city")
        else:
            engine = VedicMatchEngine()

            user_chart = engine.get_planet_data(
                datetime.combine(dob, tob),
                lat, lon
            )

            # Convert astro ‚Üí personality signals
            if user_chart["nakshatra"] <= 8:
                moon_nature = "emotionally expressive and intuitive"
            elif user_chart["nakshatra"] <= 17:
                moon_nature = "calm, observant, and grounded"
            else:
                moon_nature = "thoughtful, reflective, and private"

            if user_chart["mars_deg"] < 120:
                mars_style = "direct, energetic, and decisive"
            elif user_chart["mars_deg"] < 240:
                mars_style = "balanced, patient, and steady"
            else:
                mars_style = "chill, adaptable, and low-drama"

            astro_bio_prompt = f"""
Create a dating app bio using personality signals.

Signals:
- Emotional nature: {moon_nature}
- Action style: {mars_style}

Rules:
- Gen Z Indian tone
- No astrology words
- No emojis
- Max 2 sentences
"""

            if api_key:
                genai.configure(api_key=api_key)
                model = genai.GenerativeModel("gemini-1.5-flash")
                res = model.generate_content(
                    astro_bio_prompt,
                    generation_config={"temperature": 0.85}
                )
                st.session_state.ai_bio = res.text.strip()
            else:
                st.session_state.ai_bio = (
                    f"{moon_nature.capitalize()}. {mars_style.capitalize()}."
                )

    if c2.button("‚Üª") and st.session_state.ai_bio:
        # Recalculate signals for regeneration to ensure they're up-to-date with current inputs
        lat, lon = get_coords(city)
        if lat:
            engine = VedicMatchEngine()
            user_chart = engine.get_planet_data(datetime.combine(dob, tob), lat, lon)

            if user_chart["nakshatra"] <= 8:
                moon_nature_regen = "emotionally expressive and intuitive"
            elif user_chart["nakshatra"] <= 17:
                moon_nature_regen = "calm, observant, and grounded"
            else:
                moon_nature_regen = "thoughtful, reflective, and private"

            if user_chart["mars_deg"] < 120:
                mars_style_regen = "direct, energetic, and decisive"
            elif user_chart["mars_deg"] < 240:
                mars_style_regen = "balanced, patient, and steady"
            else:
                mars_style_regen = "chill, adaptable, and low-drama"

            astro_bio_prompt_regen = f"""
Create a dating app bio using personality signals.

Signals:
- Emotional nature: {moon_nature_regen}
- Action style: {mars_style_regen}

Rules:
- Gen Z Indian tone
- No astrology words
- No emojis
- Max 2 sentences
"""
            if api_key:
                genai.configure(api_key=api_key)
                model = genai.GenerativeModel("gemini-1.5-flash")
                res = model.generate_content(
                    astro_bio_prompt_regen,
                    generation_config={"temperature": 0.85, "candidate_count": 1}
                )
                st.session_state.ai_bio = res.text.strip()
            else:
                st.session_state.ai_bio = (
                    f"{moon_nature_regen.capitalize()}. {mars_style_regen.capitalize()}."
                )

    if st.session_state.ai_bio:
        st.markdown("#### Your Yugma Bio")
        st.info(st.session_state.ai_bio)
    # --- End Integrated AI Bio Generation ---

    if st.button("Start Journey üöÄ"):
        lat, lon = get_coords(city)
        if lat:
            st.session_state.user = {
                "name": name,
                "dob": dob,
                "tob": tob,
                "city": city,
                "lat": lat,
                "lon": lon,
                "api": api_key,
                "gender": gender # Store gender
            }
            st.session_state.page = "Modes"
            st.rerun()

elif st.session_state.page == "Modes":
    # ---------------- MODES ----------------
    st.title("Choose Your Path")

    st.markdown("<div class='card'><h3>‚ö° Swipeee</h3><p>Casual vibes. Just swipe.</p></div>", unsafe_allow_html=True)
    if st.button("Enter Swipeee"):
        if not st.session_state.profiles:
            # Use user's gender to generate dummy profiles of opposite sex
            user_gender = st.session_state.user.get("gender", "Male") # Default to Male if not found
            st.session_state.profiles = generate_dummy_profiles(user_gender)
        st.session_state.page = "Swipeee"
        st.rerun()

    st.markdown("<div class='card'><h3>üîÆ Yugma</h3><p>Astro-verified dating.</p></div>", unsafe_allow_html=True)
    if st.button("Enter Yugma"):
        st.session_state.page = "Yugma"
        st.rerun()

    st.markdown("<div class='card'><h3>‚ù§Ô∏è Matches</h3><p>People you liked.</p></div>", unsafe_allow_html=True)
    if st.button("View Matches"):
        st.session_state.page = "Matches"
        st.rerun()

elif st.session_state.page == "Matches":
    # ---------------- MATCHES ----------------
    st.title("Your Matches ‚ù§Ô∏è")
    st.caption("People you felt a spark with.")

    if not st.session_state.liked_profiles:
        st.info("No matches yet. Start swiping üíö")

    else:
        for p in st.session_state.liked_profiles:
            with st.container():
                st.markdown("<div class='card'>", unsafe_allow_html=True)

                st.image(p["img"])
                st.subheader(f"{p['name']}, {p['age']}")
                st.caption(f"üìç {p['city']}")

                st.markdown("</div>", unsafe_allow_html=True)

    if st.button("‚Üê Back"):
        st.session_state.page = "Modes"
        st.rerun()
# Add placeholder pages for Swipeee and Yugma to prevent errors when navigating to them
elif st.session_state.page == "Swipeee":
    st.title("Swipeee! ‚ö°")
    st.write("This is the Swipeee page. Implementation coming soon!")
    if st.button("‚Üê Back to Modes"):
        st.session_state.page = "Modes"
        st.rerun()
elif st.session_state.page == "Yugma":
    st.title("Yugma Mode üîÆ")
    st.write("This is the Yugma page. Implementation coming soon!")
    if st.button("‚Üê Back to Modes"):
        st.session_state.page = "Modes"
        st.rerun()

