# -*- coding: utf-8 -*-
"""AppAstro

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pyvKmVGMTElSlb3eaxD-9j7DISurV1Qa
"""

import streamlit as st
import swisseph as swe
from geopy.geocoders import MapBox
from datetime import datetime
from timezonefinder import TimezoneFinder
import pytz

# --- PAGE CONFIGURATION (TERMINAL STYLE) ---
st.set_page_config(page_title="ASTRO_KERNEL", layout="centered")

# --- CUSTOM CSS FOR HACKER AESTHETIC ---
st.markdown("""
    <style>
    /* Force Monospace Font */
    body, .stTextInput, .stButton, .stMarkdown, .stSelectbox {
        font-family: 'Courier New', Courier, monospace !important;
    }

    /* Neon Green & Black Theme Override */
    .stApp {
        background-color: #0E1117;
        color: #00FF41;
    }

    /* Input Fields */
    .stTextInput input {
        background-color: #000000;
        color: #00FF41;
        border: 1px solid #00FF41;
    }

    /* Button Styling */
    .stButton>button {
        background-color: #000000;
        color: #00FF41;
        border: 1px solid #00FF41;
        width: 100%;
    }
    .stButton>button:hover {
        background-color: #00FF41;
        color: #000000;
    }

    /* Metric Cards */
    div[data-testid="stMetricValue"] {
        font-size: 24px;
        color: #00FF41;
    }
    div[data-testid="stMetricLabel"] {
        color: #008F11;
        font-size: 14px;
    }

    /* Custom Receipt Box */
    .receipt {
        background-color: #000000;
        border: 1px solid #00FF41;
        padding: 20px;
        font-family: 'Courier New';
        margin-top: 20px;
    }
    .glitch {
        color: #FF0055;
    }
    </style>
    """, unsafe_allow_html=True)

# --- 1. CORE ENGINE ---
class VedicMatchEngine:
    def __init__(self):
        swe.set_ephe_path('')
        self.nak_to_nadi = [0,1,2,2,1,0,0,1,2, 0,1,2,2,1,0,0,1,2, 0,1,2,2,1,0,0,1,2]
        self.nak_to_gana = [0,1,2,1,0,1,0,0,0, 2,1,1,2,2,2,2,0,0, 2,1,1,0,2,2,1,0,0]
        self.rashi_lords = [2, 5, 3, 1, 0, 3, 5, 2, 4, 6, 6, 4]
        self.nak_to_yoni = [0,1,2,3,3,4,5,2,5, 6,6,7,8,9,8,9,10,10, 4,11,13,11,12,0,12,7,1]
        self.yoni_matrix = [
            [4, 2, 2, 3, 2, 2, 2, 1, 0, 1, 3, 2, 0, 2], [2, 4, 3, 3, 2, 2, 2, 2, 3, 1, 2, 3, 0, 2],
            [2, 3, 4, 2, 1, 2, 1, 3, 3, 1, 2, 0, 3, 3], [3, 3, 2, 4, 2, 1, 1, 1, 1, 2, 2, 2, 0, 0],
            [2, 2, 1, 2, 4, 2, 1, 2, 2, 1, 0, 2, 1, 1], [2, 2, 2, 1, 2, 4, 0, 2, 2, 1, 2, 3, 3, 2],
            [2, 2, 1, 1, 1, 0, 4, 2, 2, 2, 2, 1, 2], [1, 2, 3, 1, 2, 2, 2, 4, 3, 0, 3, 2, 2, 1],
            [0, 3, 3, 1, 2, 2, 2, 3, 4, 1, 2, 3, 2, 2], [1, 1, 1, 2, 1, 1, 2, 0, 1, 4, 1, 1, 2, 1],
            [3, 2, 2, 2, 0, 2, 2, 3, 2, 1, 4, 2, 2, 2], [2, 3, 0, 2, 2, 3, 2, 2, 3, 1, 2, 4, 2, 2],
            [0, 0, 3, 0, 1, 3, 1, 2, 2, 2, 2, 2, 4, 2], [2, 2, 3, 0, 1, 2, 2, 1, 2, 1, 2, 2, 2, 4]
        ]
        self.maitri_matrix = [
             [5, 5, 5, 4, 5, 0, 0], [5, 5, 4, 1, 4, 0.5, 0.5], [5, 4, 5, 0.5, 5, 3, 0.5],
             [4, 1, 0.5, 5, 0.5, 5, 4], [5, 4, 5, 0.5, 5, 0.5, 3], [0, 0.5, 3, 5, 0.5, 5, 5],
             [0, 0.5, 0.5, 4, 3, 5, 5]
        ]

    def get_planet_data(self, dt_obj, lat, lon):
        tf = TimezoneFinder()
        timezone_str = tf.timezone_at(lng=lon, lat=lat) or 'UTC'
        local_tz = pytz.timezone(timezone_str)
        local_dt = local_tz.localize(dt_obj)
        utc_dt = local_dt.astimezone(pytz.utc)

        time_dec = utc_dt.hour + (utc_dt.minute / 60.0) + (utc_dt.second / 3600.0)
        jd = swe.julday(utc_dt.year, utc_dt.month, utc_dt.day, time_dec)
        swe.set_sid_mode(swe.SIDM_LAHIRI, 0, 0)

        cusps, ascmc = swe.houses(jd, lat, lon, b'P')
        asc_deg = cusps[0]

        planets = {
            "Sun": swe.calc_ut(jd, swe.SUN, swe.FLG_SIDEREAL)[0][0],
            "Moon": swe.calc_ut(jd, swe.MOON, swe.FLG_SIDEREAL)[0][0],
            "Mars": swe.calc_ut(jd, swe.MARS, swe.FLG_SIDEREAL)[0][0],
            "Jupiter": swe.calc_ut(jd, swe.JUPITER, swe.FLG_SIDEREAL)[0][0],
            "Venus": swe.calc_ut(jd, swe.VENUS, swe.FLG_SIDEREAL)[0][0],
            "Saturn": swe.calc_ut(jd, swe.SATURN, swe.FLG_SIDEREAL)[0][0],
            "Rahu": swe.calc_ut(jd, swe.MEAN_NODE, swe.FLG_SIDEREAL)[0][0]
        }
        planets["Ketu"] = (planets["Rahu"] + 180) % 360

        def get_rashi(deg): return int(deg / 30)
        def get_house(planet_deg, start_deg):
            return (int(planet_deg/30) - int(start_deg/30) + 12) % 12 + 1

        return {
            "nakshatra": int(planets["Moon"] / 13.333333),
            "rashi": get_rashi(planets["Moon"]),
            "planets_deg": planets,
            "asc_deg": asc_deg,
            "positions": {
                p: {
                    "Lagna": get_house(deg, asc_deg),
                    "Moon": get_house(deg, planets["Moon"]),
                    "Venus": get_house(deg, planets["Venus"]),
                    "Sign": get_rashi(deg)
                } for p, deg in planets.items()
            },
        }

    def calculate_papa_points(self, data):
        malefics = ["Sun", "Mars", "Saturn", "Rahu", "Ketu"]
        dosha_houses = [1, 2, 4, 7, 8, 12]
        total_points = 0
        for planet in malefics:
            pos = data['positions'][planet]
            if pos['Lagna'] in dosha_houses: total_points += 1
            if pos['Moon'] in dosha_houses: total_points += 1
            if pos['Venus'] in dosha_houses: total_points += 1
        return total_points

    def check_manglik_specifics(self, p_data):
        house = p_data['positions']['Mars']['Lagna']
        sign = p_data['positions']['Mars']['Sign']
        mars_deg = p_data['planets_deg']['Mars']

        is_manglik = house in [1, 2, 4, 7, 8, 12]
        if not is_manglik: return 0

        if sign in [0, 7, 9, 3]: return 1
        jup_deg = p_data['planets_deg']['Jupiter']
        if abs(mars_deg - jup_deg) < 15 or abs(mars_deg - jup_deg) > 345: return 1
        sun_deg = p_data['planets_deg']['Sun']
        if abs(mars_deg - sun_deg) < 10 or abs(mars_deg - sun_deg) > 350: return 1
        return 2

    def check_sarpa_dosha(self, p_data):
        rahu_house = p_data['positions']['Rahu']['Lagna']
        ketu_house = p_data['positions']['Ketu']['Lagna']
        rahu_deg = p_data['planets_deg']['Rahu']
        ketu_deg = p_data['planets_deg']['Ketu']
        jup_deg = p_data['planets_deg']['Jupiter']

        dosha_houses = [1, 2, 4, 7, 8, 12]
        has_sarpa = (rahu_house in dosha_houses) or (ketu_house in dosha_houses)

        if not has_sarpa: return 0
        if abs(rahu_deg - jup_deg) < 15 or abs(rahu_deg - jup_deg) > 345: return 1
        if abs(ketu_deg - jup_deg) < 15 or abs(ketu_deg - jup_deg) > 345: return 1
        return 2

    def calculate_match(self, boy, girl):
        scores = {}
        scores['Varna'] = 1
        scores['Vashya'] = 2
        dist = (girl['nakshatra'] - boy['nakshatra'] + 27) % 27
        scores['Tara'] = 3 if (dist % 9) not in [0,2,4,6] else 1.5
        scores['Yoni'] = self.yoni_matrix[self.nak_to_yoni[boy['nakshatra']]][self.nak_to_yoni[girl['nakshatra']]]
        scores['Maitri'] = (self.maitri_matrix[self.rashi_lords[boy['rashi']]][self.rashi_lords[girl['rashi']]] +
                            self.maitri_matrix[self.rashi_lords[girl['rashi']]][self.rashi_lords[boy['rashi']]]) / 2
        bg, gg = self.nak_to_gana[boy['nakshatra']], self.nak_to_gana[girl['nakshatra']]
        scores['Gana'] = 6 if bg == gg else (0 if {bg, gg} == {0, 2} else 5)
        dist_r = (girl['rashi'] - boy['rashi'] + 12) % 12
        scores['Bhakoot'] = 7 if dist_r in [0, 2, 3, 6, 9, 10] else 0
        scores['Nadi'] = 0 if self.nak_to_nadi[boy['nakshatra']] == self.nak_to_nadi[girl['nakshatra']] else 8
        total = sum(scores.values())

        b_mang = self.check_manglik_specifics(boy)
        g_mang = self.check_manglik_specifics(girl)
        b_sarpa = self.check_sarpa_dosha(boy)
        g_sarpa = self.check_sarpa_dosha(girl)
        b_papa = self.calculate_papa_points(boy)
        g_papa = self.calculate_papa_points(girl)

        return total, b_mang, g_mang, b_sarpa, g_sarpa, b_papa, g_papa, scores['Maitri'], scores['Nadi']

# --- 2. LOCATION UTILS ---
@st.cache_data
def get_coords(city_name):
    known_cities = {
        "adoor": (9.1529, 76.7356), "chennai": (13.0827, 80.2707),
        "delhi": (28.7041, 77.1025), "mumbai": (19.0760, 72.8777),
        "bangalore": (12.9716, 77.5946)
    }
    clean = city_name.lower().split(',')[0].strip()
    if clean in known_cities: return known_cities[clean]

    MAPBOX_KEY = "pk.eyJ1IjoiY3JhYW0iLCJhIjoiY21qdmwycGtpMmJrdzNlc2RyeGh4NzI0ZCJ9.QDE8TkUAQFswm2XFBBxxaw"
    try:
        geolocator = MapBox(api_key=MAPBOX_KEY, user_agent="astro_genz_v1")
        location = geolocator.geocode(city_name)
        if location: return location.latitude, location.longitude
        return None, None
    except:
        return None, None

# --- 3. UI: TERMINAL INTERFACE ---
st.markdown("### >>> INITIALIZING ASTRO_SWIPE KERNEL v2.0...")

min_date = datetime(1900, 1, 1)
max_date = datetime(2100, 12, 31)

# Input Form
c1, c2 = st.columns(2)
with c1:
    st.markdown("**// USER_01 [MALE]**")
    b_name = st.text_input("ID_STR", "X", key="b1")
    b_date = st.date_input("DATE_INIT", datetime(1959, 12, 24), min_value=min_date, max_value=max_date, key="b2")
    b_time = st.time_input("TIME_INIT", datetime.strptime("06:34", "%H:%M").time(), key="b3")
    b_place = st.text_input("GEO_LOC", "Adoor, India", key="b4")

with c2:
    st.markdown("**// USER_02 [FEMALE]**")
    g_name = st.text_input("ID_STR", "Y", key="g1")
    g_date = st.date_input("DATE_INIT", datetime(1963, 2, 17), min_value=min_date, max_value=max_date, key="g2")
    g_time = st.time_input("TIME_INIT", datetime.strptime("09:04", "%H:%M").time(), key="g3")
    g_place = st.text_input("GEO_LOC", "Chennai, India", key="g4")

st.markdown("---")

if st.button("[ EXECUTE_COMPATIBILITY_PROTOCOL ]"):
    with st.spinner("PARSING CELESTIAL DATA..."):
        b_lat, b_lon = get_coords(b_place)
        g_lat, g_lon = get_coords(g_place)

        if not b_lat or not g_lat:
            st.error("ERR: GEO_LOC_NOT_FOUND")
            st.stop()

        b_dt = datetime.combine(b_date, b_time)
        g_dt = datetime.combine(g_date, g_time)

        engine = VedicMatchEngine()
        b_data = engine.get_planet_data(b_dt, b_lat, b_lon)
        g_data = engine.get_planet_data(g_dt, g_lat, g_lon)

        # Calculations
        score, b_mang, g_mang, b_sarpa, g_sarpa, b_papa, g_papa, maitri, nadi = engine.calculate_match(b_data, g_data)

    # --- LOGIC TRANSLATION TO HACKER SPEAK ---

    # 1. SYNC_RATE (Vibe Score)
    sync_rate = f"{int((score/36)*100)}%"

    # 2. THREAT_LEVEL (Red Flags)
    manglik_ok = (b_mang == g_mang) or (b_mang <= 1 and g_mang <= 1)
    sarpa_ok = (b_sarpa == g_sarpa) or (b_sarpa <= 1 and g_sarpa <= 1)

    # Love Override
    override_active = False
    if score >= 20:
        if not sarpa_ok: sarpa_ok = True
        if not manglik_ok and (b_mang <= 1 or g_mang <= 1): manglik_ok = True
        override_active = True

    if manglik_ok and sarpa_ok:
        if b_mang == 2 or b_sarpa == 2: threat_txt = "NEUTRALIZED"
        else: threat_txt = "NULL"
    elif not manglik_ok: threat_txt = "CRITICAL_MANGLIK"
    else: threat_txt = "CRITICAL_SARPA"

    # 3. CHAOS_METER (Drama)
    if g_papa > (b_papa + 2): chaos_txt = "VOLATILE"
    else: chaos_txt = "STABLE"

    # 4. CHEMISTRY_LOG (Friends)
    if maitri >= 4: chem_txt = "LOCKED_IN"
    elif maitri >= 2: chem_txt = "CASUAL"
    else: chem_txt = "OPPS"

    # 5. LEGACY_PROTOCOL (Family)
    if nadi == 8: legacy_txt = "OPTIMAL"
    else: legacy_txt = "CORRUPTED" # Nadi Dosha

    # FINAL_OUTPUT
    if (score >= 18) and (manglik_ok and sarpa_ok) and (chaos_txt == "STABLE"):
        sys_status = "SYSTEM_GO"
        sys_msg = "COMPATIBILITY CONFIRMED."
        color_code = "#00FF41" # Green
    elif score >= 18:
        sys_status = "SYSTEM_WARN"
        sys_msg = "PROCEED WITH CAUTION. BUGS DETECTED."
        color_code = "#FFA500" # Orange
    else:
        sys_status = "SYSTEM_HALT"
        sys_msg = "FATAL ERROR. DO NOT PROCEED."
        color_code = "#FF0055" # Red

    # --- RENDER RECEIPT ---
    st.markdown(f"""
    <div class="receipt" style="border-color: {color_code};">
        <h2 style="color: {color_code}; margin-top: 0;">>> DIAGNOSTIC_REPORT</h2>
        <p>UID_01: {b_name.upper()} | UID_02: {g_name.upper()}</p>
        <p>TIMESTAMP: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        <hr style="border-top: 1px dashed {color_code};">

        <table style="width:100%; color: {color_code};">
            <tr>
                <td style="padding: 10px;">SYNC_RATE (VIBE)</td>
                <td style="text-align: right; font-weight: bold;">{sync_rate} [{score}/36]</td>
            </tr>
            <tr>
                <td style="padding: 10px;">THREAT_LEVEL</td>
                <td style="text-align: right; font-weight: bold;">{threat_txt}</td>
            </tr>
            <tr>
                <td style="padding: 10px;">CHAOS_METER</td>
                <td style="text-align: right; font-weight: bold;">{chaos_txt}</td>
            </tr>
            <tr>
                <td style="padding: 10px;">CHEMISTRY_LOG</td>
                <td style="text-align: right; font-weight: bold;">{chem_txt}</td>
            </tr>
            <tr>
                <td style="padding: 10px;">LEGACY_PROTOCOL</td>
                <td style="text-align: right; font-weight: bold;">{legacy_txt}</td>
            </tr>
        </table>

        <hr style="border-top: 1px dashed {color_code};">
        <h1 style="text-align: center; color: {color_code}; font-size: 40px; margin-bottom: 0;">{sys_status}</h1>
        <p style="text-align: center; color: #FFFFFF;">{sys_msg}</p>
        <p style="text-align: center; font-size: 10px; opacity: 0.7;">OVERRIDE_ACTIVE: {str(override_active).upper()}</p>
    </div>
    """, unsafe_allow_html=True)